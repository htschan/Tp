/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.9.0.0 (NJsonSchema v9.7.3.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

export interface ITpClient {
    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return Returns nothing
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse>;
    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse>;
    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse>;
    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse>;
    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse>;
    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse>;
    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse>;
    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<GetProfilesResponse>;
    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<GetProfileResponse>;
    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<GetProfileResponse>;
    /**
     * Get the list of users [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns users
     */
    adminGetUsers(): Observable<UsersDto>;
    /**
     * Get the list of sessions [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns sessions
     */
    adminGetSessions(): Observable<SessionsDto>;
    /**
     * Retrieves all punches of current user
     * @return An array of products
     */
    getPunches(): Observable<PunchDto[]>;
    /**
     * Retrieves all punches of current user of selected day
     * @day The day selector [1 .. 31]
     * @month The month number selector [1 .. 12]
     * @year The year number selector [2015 .. 2099]
     * @return An day punches object
     */
    getDay(day: number | null, month: number | null, year: number | null): Observable<DayResponse>;
    /**
     * Retrieves all punches of current user selected week
     * @week The week number selector
     * @year The year number selector [2015 .. 2099]
     * @return A week punches object
     */
    getWeek(week: number | null, year: number | null): Observable<WeekResponse>;
    /**
     * Retrieves all punches of current user of selected month
     * @month The month number selector [1 .. 12]
     * @year The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    getMonth(month: number | null, year: number | null): Observable<MonthResponse>;
    /**
     * Retrieves all punches of current user of selected year
     * @year The year number selector [2015 .. 2099]
     * @return A year punches object
     */
    getYear(year: number | null): Observable<YearResponse>;
    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchIn(): Observable<DayResponse>;
    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchOut(): Observable<DayResponse>;
    /**
     * Modifiziert einen Zeitstempel
     * @return Unexpected error
     */
    punchModify(modifyPunchDto: ModifyPunchDto | null): Observable<PunchResponse>;
    /**
     * Löscht einen Zeitstempel
     * @return Unexpected error
     */
    punchDelete(deletePunchDto: DeletePunchDto | null): Observable<OpResult>;
    /**
     * Get the list of users [Authorize(Policy = "RequireApiPowerRole")]
     * @return Returns users
     */
    puGetUsers(): Observable<UsersDto>;
    /**
     * Retrieves all punches of current user of selected month
     * @userId The user id
     * @month The month number selector [1 .. 12]
     * @year The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    puGetMonth(userId: string, month: number | null, year: number | null): Observable<MonthResponse>;
    /**
     * Modifiziert einen Zeitstempel [Authorize(Policy = "RequireApiPowerRole")]
     * @return Unexpected error
     */
    punchModifyAdmin(modifyPunchAdminDto: ModifyPunchAdminDto | null): Observable<PunchResponse>;
    /**
     * Setzt den Status der Monatsabrechung [Authorize(Policy = "RequireApiPowerRole")]
     * @return Unexpected error
     */
    punchSetStatusAdmin(setStatusAdminDto: StatusAdminDto | null): Observable<PunchResponse>;
}

@Injectable()
export class TpClient implements ITpClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api/v1";
    }

    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return Returns nothing
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAuthenticate(response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthResponse>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: Response): Observable<AuthResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthResponse.fromJS(resultData200) : new AuthResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/refreshtoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshtokenparameter);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefreshtoken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefreshtoken(response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthResponse>><any>Observable.throw(response_);
        });
    }

    protected processRefreshtoken(response: Response): Observable<AuthResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? AuthResponse.fromJS(resultData) : new AuthResponse();
            return Observable.of(result);
        }
    }

    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRegisterUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegisterUser(response_);
                } catch (e) {
                    return <Observable<RegisterResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterResponse>><any>Observable.throw(response_);
        });
    }

    protected processRegisterUser(response: Response): Observable<RegisterResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterResponse.fromJS(resultData200) : new RegisterResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse> {
        let url_ = this.baseUrl + "/confirm?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (cnf === undefined || cnf === null)
            throw new Error("The parameter 'cnf' must be defined and cannot be null.");
        else
            url_ += "cnf=" + encodeURIComponent("" + cnf) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processConfirmRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processConfirmRegister(response_);
                } catch (e) {
                    return <Observable<ConfirmResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConfirmResponse>><any>Observable.throw(response_);
        });
    }

    protected processConfirmRegister(response: Response): Observable<ConfirmResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConfirmResponse.fromJS(resultData200) : new ConfirmResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse> {
        let url_ = this.baseUrl + "/recoverPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverPasswordParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRecoverPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecoverPassword(response_);
                } catch (e) {
                    return <Observable<RecoverPasswordResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecoverPasswordResponse>><any>Observable.throw(response_);
        });
    }

    protected processRecoverPassword(response: Response): Observable<RecoverPasswordResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverPasswordResponse.fromJS(resultData200) : new RecoverPasswordResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse> {
        let url_ = this.baseUrl + "/recoverUsername";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverUsernameParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRecoverUsername(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecoverUsername(response_);
                } catch (e) {
                    return <Observable<RecoverUsernameResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecoverUsernameResponse>><any>Observable.throw(response_);
        });
    }

    protected processRecoverUsername(response: Response): Observable<RecoverUsernameResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverUsernameResponse.fromJS(resultData200) : new RecoverUsernameResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse> {
        let url_ = this.baseUrl + "/setPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setPasswordParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetPassword(response_);
                } catch (e) {
                    return <Observable<SetPasswordResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<SetPasswordResponse>><any>Observable.throw(response_);
        });
    }

    protected processSetPassword(response: Response): Observable<SetPasswordResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetPasswordResponse.fromJS(resultData200) : new SetPasswordResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<GetProfilesResponse> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetProfiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfiles(response_);
                } catch (e) {
                    return <Observable<GetProfilesResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilesResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetProfiles(response: Response): Observable<GetProfilesResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilesResponse.fromJS(resultData200) : new GetProfilesResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<GetProfileResponse> {
        let url_ = this.baseUrl + "/profiles/myprofile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetMyProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMyProfile(response_);
                } catch (e) {
                    return <Observable<GetProfileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetMyProfile(response: Response): Observable<GetProfileResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResponse.fromJS(resultData200) : new GetProfileResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<GetProfileResponse> {
        let url_ = this.baseUrl + "/profiles/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfile(response_);
                } catch (e) {
                    return <Observable<GetProfileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetProfile(response: Response): Observable<GetProfileResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResponse.fromJS(resultData200) : new GetProfileResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Get the list of users [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns users
     */
    adminGetUsers(): Observable<UsersDto> {
        let url_ = this.baseUrl + "/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAdminGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAdminGetUsers(response_);
                } catch (e) {
                    return <Observable<UsersDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersDto>><any>Observable.throw(response_);
        });
    }

    protected processAdminGetUsers(response: Response): Observable<UsersDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersDto.fromJS(resultData200) : new UsersDto();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Get the list of sessions [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns sessions
     */
    adminGetSessions(): Observable<SessionsDto> {
        let url_ = this.baseUrl + "/admin/sessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAdminGetSessions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAdminGetSessions(response_);
                } catch (e) {
                    return <Observable<SessionsDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<SessionsDto>><any>Observable.throw(response_);
        });
    }

    protected processAdminGetSessions(response: Response): Observable<SessionsDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SessionsDto.fromJS(resultData200) : new SessionsDto();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Retrieves all punches of current user
     * @return An array of products
     */
    getPunches(): Observable<PunchDto[]> {
        let url_ = this.baseUrl + "/punches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetPunches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPunches(response_);
                } catch (e) {
                    return <Observable<PunchDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetPunches(response: Response): Observable<PunchDto[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PunchDto.fromJS(item));
            }
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Retrieves all punches of current user of selected day
     * @day The day selector [1 .. 31]
     * @month The month number selector [1 .. 12]
     * @year The year number selector [2015 .. 2099]
     * @return An day punches object
     */
    getDay(day: number | null, month: number | null, year: number | null): Observable<DayResponse> {
        let url_ = this.baseUrl + "/punches/day?";
        if (day !== undefined)
            url_ += "day=" + encodeURIComponent("" + day) + "&"; 
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetDay(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDay(response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetDay(response: Response): Observable<DayResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Retrieves all punches of current user selected week
     * @week The week number selector
     * @year The year number selector [2015 .. 2099]
     * @return A week punches object
     */
    getWeek(week: number | null, year: number | null): Observable<WeekResponse> {
        let url_ = this.baseUrl + "/punches/week?";
        if (week !== undefined)
            url_ += "week=" + encodeURIComponent("" + week) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetWeek(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetWeek(response_);
                } catch (e) {
                    return <Observable<WeekResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<WeekResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetWeek(response: Response): Observable<WeekResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeekResponse.fromJS(resultData200) : new WeekResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Retrieves all punches of current user of selected month
     * @month The month number selector [1 .. 12]
     * @year The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    getMonth(month: number | null, year: number | null): Observable<MonthResponse> {
        let url_ = this.baseUrl + "/punches/month?";
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetMonth(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMonth(response_);
                } catch (e) {
                    return <Observable<MonthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<MonthResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetMonth(response: Response): Observable<MonthResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MonthResponse.fromJS(resultData200) : new MonthResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Retrieves all punches of current user of selected year
     * @year The year number selector [2015 .. 2099]
     * @return A year punches object
     */
    getYear(year: number | null): Observable<YearResponse> {
        let url_ = this.baseUrl + "/punches/year?";
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetYear(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetYear(response_);
                } catch (e) {
                    return <Observable<YearResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<YearResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetYear(response: Response): Observable<YearResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? YearResponse.fromJS(resultData200) : new YearResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchIn(): Observable<DayResponse> {
        let url_ = this.baseUrl + "/punches/punch/In";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchIn(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchIn(response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchIn(response: Response): Observable<DayResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchOut(): Observable<DayResponse> {
        let url_ = this.baseUrl + "/punches/punch/Out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchOut(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchOut(response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchOut(response: Response): Observable<DayResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Modifiziert einen Zeitstempel
     * @return Unexpected error
     */
    punchModify(modifyPunchDto: ModifyPunchDto | null): Observable<PunchResponse> {
        let url_ = this.baseUrl + "/punchModify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyPunchDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchModify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchModify(response_);
                } catch (e) {
                    return <Observable<PunchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchModify(response: Response): Observable<PunchResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return Observable.of(result);
        }
    }

    /**
     * Löscht einen Zeitstempel
     * @return Unexpected error
     */
    punchDelete(deletePunchDto: DeletePunchDto | null): Observable<OpResult> {
        let url_ = this.baseUrl + "/punchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deletePunchDto);
        
        let options_ = {
            body: content_,
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchDelete(response_);
                } catch (e) {
                    return <Observable<OpResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<OpResult>><any>Observable.throw(response_);
        });
    }

    protected processPunchDelete(response: Response): Observable<OpResult> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return Observable.of(result);
        }
    }

    /**
     * Get the list of users [Authorize(Policy = "RequireApiPowerRole")]
     * @return Returns users
     */
    puGetUsers(): Observable<UsersDto> {
        let url_ = this.baseUrl + "/poweruser/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPuGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPuGetUsers(response_);
                } catch (e) {
                    return <Observable<UsersDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UsersDto>><any>Observable.throw(response_);
        });
    }

    protected processPuGetUsers(response: Response): Observable<UsersDto> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersDto.fromJS(resultData200) : new UsersDto();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Retrieves all punches of current user of selected month
     * @userId The user id
     * @month The month number selector [1 .. 12]
     * @year The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    puGetMonth(userId: string, month: number | null, year: number | null): Observable<MonthResponse> {
        let url_ = this.baseUrl + "/poweruser/punches/month?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPuGetMonth(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPuGetMonth(response_);
                } catch (e) {
                    return <Observable<MonthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<MonthResponse>><any>Observable.throw(response_);
        });
    }

    protected processPuGetMonth(response: Response): Observable<MonthResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MonthResponse.fromJS(resultData200) : new MonthResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, _headers, result);
        }
    }

    /**
     * Modifiziert einen Zeitstempel [Authorize(Policy = "RequireApiPowerRole")]
     * @return Unexpected error
     */
    punchModifyAdmin(modifyPunchAdminDto: ModifyPunchAdminDto | null): Observable<PunchResponse> {
        let url_ = this.baseUrl + "/poweruser/punchModify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyPunchAdminDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchModifyAdmin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchModifyAdmin(response_);
                } catch (e) {
                    return <Observable<PunchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchModifyAdmin(response: Response): Observable<PunchResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return Observable.of(result);
        }
    }

    /**
     * Setzt den Status der Monatsabrechung [Authorize(Policy = "RequireApiPowerRole")]
     * @return Unexpected error
     */
    punchSetStatusAdmin(setStatusAdminDto: StatusAdminDto | null): Observable<PunchResponse> {
        let url_ = this.baseUrl + "/poweruser/punchSetStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setStatusAdminDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchSetStatusAdmin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchSetStatusAdmin(response_);
                } catch (e) {
                    return <Observable<PunchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchSetStatusAdmin(response: Response): Observable<PunchResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        {
            const _responseText = response.text();
            let result: any = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return Observable.of(result);
        }
    }
}

export class AuthResponse implements IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.validFor = data["validFor"];
            this.id = data["id"];
            this.token = data["token"];
            this.refreshtoken = data["refreshtoken"];
        }
    }

    static fromJS(data: any): AuthResponse {
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["validFor"] = this.validFor;
        data["id"] = this.id;
        data["token"] = this.token;
        data["refreshtoken"] = this.refreshtoken;
        return data; 
    }
}

export interface IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;
}

export class CredentialDto implements ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ICredentialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.client_type = data["client_type"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CredentialDto {
        let result = new CredentialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_type"] = this.client_type;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.refresh_token = data["refresh_token"];
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refresh_token"] = this.refresh_token;
        return data; 
    }
}

export interface IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstname = data["firstname"];
            this.name = data["name"];
            this.email = data["email"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["name"] = this.name;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RegisterResponse implements IRegisterResponse {
    status?: OpResult | undefined;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterResponse {
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterResponse {
    status?: OpResult | undefined;
}

export class ConfirmResponse implements IConfirmResponse {
    status?: OpResult | undefined;

    constructor(data?: IConfirmResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmResponse {
        let result = new ConfirmResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConfirmResponse {
    status?: OpResult | undefined;
}

export class RecoverPasswordParams implements IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;

    constructor(data?: IRecoverPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): RecoverPasswordParams {
        let result = new RecoverPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        return data; 
    }
}

export interface IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
}

export class RecoverUsernameParams implements IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;

    constructor(data?: IRecoverUsernameParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): RecoverUsernameParams {
        let result = new RecoverUsernameParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
}

export class RecoverPasswordResponse implements IRecoverPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverPasswordResponse {
        let result = new RecoverPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverPasswordResponse {
    status?: OpResult | undefined;
}

export class RecoverUsernameResponse implements IRecoverUsernameResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverUsernameResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverUsernameResponse {
        let result = new RecoverUsernameResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverUsernameResponse {
    status?: OpResult | undefined;
}

export class SetPasswordParams implements ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ISetPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): SetPasswordParams {
        let result = new SetPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class SetPasswordResponse implements ISetPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: ISetPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetPasswordResponse {
        let result = new SetPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetPasswordResponse {
    status?: OpResult | undefined;
}

export class GetProfilesResponse implements IGetProfilesResponse {
    status?: OpResult | undefined;

    constructor(data?: IGetProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProfilesResponse {
        let result = new GetProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProfilesResponse {
    status?: OpResult | undefined;
}

export class GetProfileResponse implements IGetProfileResponse {
    status?: OpResult | undefined;

    constructor(data?: IGetProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProfileResponse {
        let result = new GetProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProfileResponse {
    status?: OpResult | undefined;
}

export class PunchResponse implements IPunchResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;

    constructor(data?: IPunchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? DayPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PunchResponse {
        let result = new PunchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPunchResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;
}

export class DayResponse implements IDayResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;

    constructor(data?: IDayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? DayPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DayResponse {
        let result = new DayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDayResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;
}

export class WeekResponse implements IWeekResponse {
    status?: OpResult | undefined;
    punches?: WeekPunchesDto | undefined;

    constructor(data?: IWeekResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? WeekPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WeekResponse {
        let result = new WeekResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWeekResponse {
    status?: OpResult | undefined;
    punches?: WeekPunchesDto | undefined;
}

export class MonthResponse implements IMonthResponse {
    status?: OpResult | undefined;
    punches?: MonthPunchesDto | undefined;

    constructor(data?: IMonthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? MonthPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MonthResponse {
        let result = new MonthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMonthResponse {
    status?: OpResult | undefined;
    punches?: MonthPunchesDto | undefined;
}

export class YearResponse implements IYearResponse {
    status?: OpResult | undefined;
    punches?: YearPunchesDto | undefined;

    constructor(data?: IYearResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? YearPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): YearResponse {
        let result = new YearResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IYearResponse {
    status?: OpResult | undefined;
    punches?: YearPunchesDto | undefined;
}

export class ModifyPunchDto implements IModifyPunchDto {
    punchid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;

    constructor(data?: IModifyPunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
            this.timedec = data["timedec"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): ModifyPunchDto {
        let result = new ModifyPunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IModifyPunchDto {
    punchid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;
}

export class DeletePunchDto implements IDeletePunchDto {
    punchid?: string | undefined;

    constructor(data?: IDeletePunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
        }
    }

    static fromJS(data: any): DeletePunchDto {
        let result = new DeletePunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        return data; 
    }
}

export interface IDeletePunchDto {
    punchid?: string | undefined;
}

export class ModifyPunchAdminDto implements IModifyPunchAdminDto {
    punchid?: string | undefined;
    userid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;

    constructor(data?: IModifyPunchAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
            this.userid = data["userid"];
            this.timedec = data["timedec"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): ModifyPunchAdminDto {
        let result = new ModifyPunchAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        data["userid"] = this.userid;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IModifyPunchAdminDto {
    punchid?: string | undefined;
    userid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;
}

export class StatusAdminDto implements IStatusAdminDto {
    userid?: string | undefined;
    status?: StatusAdminDtoStatus | undefined = StatusAdminDtoStatus.Open;

    constructor(data?: IStatusAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userid = data["userid"];
            this.status = data["status"] !== undefined ? data["status"] : StatusAdminDtoStatus.Open;
        }
    }

    static fromJS(data: any): StatusAdminDto {
        let result = new StatusAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userid"] = this.userid;
        data["status"] = this.status;
        return data; 
    }
}

export interface IStatusAdminDto {
    userid?: string | undefined;
    status?: StatusAdminDtoStatus | undefined;
}

export class UsersDto implements IUsersDto {
    users?: UserDto[] | undefined;

    constructor(data?: IUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersDto {
        let result = new UsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsersDto {
    users?: UserDto[] | undefined;
}

export class UserDto implements IUserDto {
    /** Then user id */
    id?: string | undefined;
    /** The first name of user */
    firstName?: string | undefined;
    /** The last name of user */
    lastName?: string | undefined;
    /** The email of the user */
    email?: string | undefined;
    /** The confirmed status of the user registration */
    emailConfirmed?: boolean | undefined;
    /** The number of failed access attempts */
    accessFailedCount?: number | undefined;
    roleNames?: RoleDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.emailConfirmed = data["emailConfirmed"];
            this.accessFailedCount = data["accessFailedCount"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["accessFailedCount"] = this.accessFailedCount;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserDto {
    /** Then user id */
    id?: string | undefined;
    /** The first name of user */
    firstName?: string | undefined;
    /** The last name of user */
    lastName?: string | undefined;
    /** The email of the user */
    email?: string | undefined;
    /** The confirmed status of the user registration */
    emailConfirmed?: boolean | undefined;
    /** The number of failed access attempts */
    accessFailedCount?: number | undefined;
    roleNames?: RoleDto[] | undefined;
}

export class RoleDto implements IRoleDto {
    /** Name of role */
    name?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IRoleDto {
    /** Name of role */
    name?: string | undefined;
}

export class SessionsDto implements ISessionsDto {
    sessions?: SessionDto[] | undefined;

    constructor(data?: ISessionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["sessions"] && data["sessions"].constructor === Array) {
                this.sessions = [];
                for (let item of data["sessions"])
                    this.sessions.push(SessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SessionsDto {
        let result = new SessionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sessions && this.sessions.constructor === Array) {
            data["sessions"] = [];
            for (let item of this.sessions)
                data["sessions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISessionsDto {
    sessions?: SessionDto[] | undefined;
}

export class SessionDto implements ISessionDto {
    /** Then sessions id */
    id?: string | undefined;
    /** The userid associated with the session */
    userid?: string | undefined;
    /** the email of the user */
    email?: string | undefined;
    /** The timestamp of the creation */
    created?: string | undefined;
    /** True if the session is stopped */
    isStop?: boolean | undefined;

    constructor(data?: ISessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userid = data["userid"];
            this.email = data["email"];
            this.created = data["created"];
            this.isStop = data["isStop"];
        }
    }

    static fromJS(data: any): SessionDto {
        let result = new SessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userid"] = this.userid;
        data["email"] = this.email;
        data["created"] = this.created;
        data["isStop"] = this.isStop;
        return data; 
    }
}

export interface ISessionDto {
    /** Then sessions id */
    id?: string | undefined;
    /** The userid associated with the session */
    userid?: string | undefined;
    /** the email of the user */
    email?: string | undefined;
    /** The timestamp of the creation */
    created?: string | undefined;
    /** True if the session is stopped */
    isStop?: boolean | undefined;
}

export class YearPunchesDto implements IYearPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: MonthPunchesDto[] | undefined;

    constructor(data?: IYearPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(MonthPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YearPunchesDto {
        let result = new YearPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IYearPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: MonthPunchesDto[] | undefined;
}

export class MonthPunchesDto implements IMonthPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    state?: StatusAdminDto | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: DayPunchesDto[] | undefined;

    constructor(data?: IMonthPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.state = data["state"] ? StatusAdminDto.fromJS(data["state"]) : <any>undefined;
            this.month = data["month"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(DayPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MonthPunchesDto {
        let result = new MonthPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMonthPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    state?: StatusAdminDto | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: DayPunchesDto[] | undefined;
}

export class WeekPunchesDto implements IWeekPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The week expressed as 1 to 53 */
    week?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    dayPunches?: DayPunchesDto[] | undefined;

    constructor(data?: IWeekPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.week = data["week"];
            this.year = data["year"];
            if (data["dayPunches"] && data["dayPunches"].constructor === Array) {
                this.dayPunches = [];
                for (let item of data["dayPunches"])
                    this.dayPunches.push(DayPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeekPunchesDto {
        let result = new WeekPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["week"] = this.week;
        data["year"] = this.year;
        if (this.dayPunches && this.dayPunches.constructor === Array) {
            data["dayPunches"] = [];
            for (let item of this.dayPunches)
                data["dayPunches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeekPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The week expressed as 1 to 53 */
    week?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    dayPunches?: DayPunchesDto[] | undefined;
}

export class DayPunchesDto implements IDayPunchesDto {
    /** Boid of user */
    userboid?: string | undefined;
    /** The day expressed as value betwenn 1 and 31 */
    day?: number | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: PunchRowDto[] | undefined;
    daytotal?: number | undefined;

    constructor(data?: IDayPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userboid = data["userboid"];
            this.day = data["day"];
            this.month = data["month"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(PunchRowDto.fromJS(item));
            }
            this.daytotal = data["daytotal"];
        }
    }

    static fromJS(data: any): DayPunchesDto {
        let result = new DayPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userboid"] = this.userboid;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        data["daytotal"] = this.daytotal;
        return data; 
    }
}

export interface IDayPunchesDto {
    /** Boid of user */
    userboid?: string | undefined;
    /** The day expressed as value betwenn 1 and 31 */
    day?: number | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: PunchRowDto[] | undefined;
    daytotal?: number | undefined;
}

export class PunchRowDto implements IPunchRowDto {
    enter?: PunchDto | undefined;
    leave?: PunchDto | undefined;
    /** Time between enter and leav */
    rowTotal?: number | undefined;

    constructor(data?: IPunchRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.enter = data["enter"] ? PunchDto.fromJS(data["enter"]) : <any>undefined;
            this.leave = data["leave"] ? PunchDto.fromJS(data["leave"]) : <any>undefined;
            this.rowTotal = data["rowTotal"];
        }
    }

    static fromJS(data: any): PunchRowDto {
        let result = new PunchRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enter"] = this.enter ? this.enter.toJSON() : <any>undefined;
        data["leave"] = this.leave ? this.leave.toJSON() : <any>undefined;
        data["rowTotal"] = this.rowTotal;
        return data; 
    }
}

export interface IPunchRowDto {
    enter?: PunchDto | undefined;
    leave?: PunchDto | undefined;
    /** Time between enter and leav */
    rowTotal?: number | undefined;
}

export class PunchDto implements IPunchDto {
    time?: Date | undefined;
    timedec?: number | undefined;
    /** True means enter work, False means leave work. */
    direction?: boolean | undefined;
    /** The timestamp of the creation of this value. */
    created?: Date | undefined;
    /** The timestamp of the last update of this value. */
    updated?: Date | undefined;
    punchid?: string | undefined;

    constructor(data?: IPunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.timedec = data["timedec"];
            this.direction = data["direction"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.updated = data["updated"] ? new Date(data["updated"].toString()) : <any>undefined;
            this.punchid = data["punchid"];
        }
    }

    static fromJS(data: any): PunchDto {
        let result = new PunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["punchid"] = this.punchid;
        return data; 
    }
}

export interface IPunchDto {
    time?: Date | undefined;
    timedec?: number | undefined;
    /** True means enter work, False means leave work. */
    direction?: boolean | undefined;
    /** The timestamp of the creation of this value. */
    created?: Date | undefined;
    /** The timestamp of the last update of this value. */
    updated?: Date | undefined;
    punchid?: string | undefined;
}

export class OpResult implements IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;

    constructor(data?: IOpResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): OpResult {
        let result = new OpResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["result"] = this.result;
        return data; 
    }
}

export interface IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;
}

export enum StatusAdminDtoStatus {
    Open = <any>"open", 
    OpenAdmin = <any>"openAdmin", 
    Closed = <any>"closed", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
	headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
		super();

        this.message = message;
        this.status = status;
        this.response = response;
		this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}