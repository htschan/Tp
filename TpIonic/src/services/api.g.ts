/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.3.3.0 (NJsonSchema v9.4.2.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

export interface ITpClient {
    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse | null>;
    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse | null>;
    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse | null>;
    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse | null>;
    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse | null>;
    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse | null>;
    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse | null>;
    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<GetProfilesResponse | null>;
    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<GetProfileResponse | null>;
    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<GetProfileResponse | null>;
    /**
     * Retrieves all punches of current user
     * @return An array of products
     */
    getPunches(): Observable<PunchDto[] | null>;
    /**
     * Retrieves all punches of current user of today
     * @return An day punches object
     */
    getToday(): Observable<DayResponse | null>;
    /**
     * Retrieves all punches of current user current week
     * @return A week punches object
     */
    getThisWeek(): Observable<WeekResponse | null>;
    /**
     * Retrieves all punches of current user of current month
     * @return A month punches object
     */
    getThisMonth(): Observable<MonthResponse | null>;
    /**
     * Retrieves all punches of current user of current year
     * @return A year punches object
     */
    getThisYear(): Observable<YearResponse | null>;
    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchIn(): Observable<DayResponse | null>;
    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchOut(): Observable<DayResponse | null>;
    /**
     * Modifiziert einen Zeitstempel
     * @return Unexpected error
     */
    punchModify(modifyPunchDto: ModifyPunchDto | undefined): Observable<PunchResponse | null>;
    /**
     * Löscht einen Zeitstempel
     * @return Unexpected error
     */
    punchDelete(deletePunchDto: DeletePunchDto | undefined): Observable<OpResult | null>;
    /**
     * Modifiziert einen Zeitstempel
     * @return Unexpected error
     */
    punchModifyAdmin(modifyPunchAdminDto: ModifyPunchAdminDto | undefined): Observable<PunchResponse | null>;
    /**
     * Setzt den Status der Monatsabrechung
     * @return Unexpected error
     */
    punchSetStatusAdmin(setStatusAdminDto: SetStatusAdminDto | undefined): Observable<PunchResponse | null>;
}

@Injectable()
export class TpClient implements ITpClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api/v1";
    }

    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse | null> {
        let url_ = this.baseUrl + "/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAuthenticate(response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthResponse>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: Response): Observable<AuthResponse | null> {
        const status = response.status; 

        {
            const _responseText = response.text();
            let result: AuthResponse | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? AuthResponse.fromJS(resultData) : new AuthResponse();
            return Observable.of(result);
        }
    }

    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse | null> {
        let url_ = this.baseUrl + "/refreshtoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshtokenparameter);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefreshtoken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefreshtoken(response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthResponse>><any>Observable.throw(response_);
        });
    }

    protected processRefreshtoken(response: Response): Observable<AuthResponse | null> {
        const status = response.status; 

        {
            const _responseText = response.text();
            let result: AuthResponse | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? AuthResponse.fromJS(resultData) : new AuthResponse();
            return Observable.of(result);
        }
    }

    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse | null> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRegisterUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegisterUser(response_);
                } catch (e) {
                    return <Observable<RegisterResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterResponse>><any>Observable.throw(response_);
        });
    }

    protected processRegisterUser(response: Response): Observable<RegisterResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: RegisterResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterResponse.fromJS(resultData200) : new RegisterResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse | null> {
        let url_ = this.baseUrl + "/confirm?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (cnf === undefined || cnf === null)
            throw new Error("The parameter 'cnf' must be defined and cannot be null.");
        else
            url_ += "cnf=" + encodeURIComponent("" + cnf) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processConfirmRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processConfirmRegister(response_);
                } catch (e) {
                    return <Observable<ConfirmResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConfirmResponse>><any>Observable.throw(response_);
        });
    }

    protected processConfirmRegister(response: Response): Observable<ConfirmResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ConfirmResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConfirmResponse.fromJS(resultData200) : new ConfirmResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse | null> {
        let url_ = this.baseUrl + "/recoverPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverPasswordParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRecoverPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecoverPassword(response_);
                } catch (e) {
                    return <Observable<RecoverPasswordResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecoverPasswordResponse>><any>Observable.throw(response_);
        });
    }

    protected processRecoverPassword(response: Response): Observable<RecoverPasswordResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: RecoverPasswordResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverPasswordResponse.fromJS(resultData200) : new RecoverPasswordResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse | null> {
        let url_ = this.baseUrl + "/recoverUsername";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverUsernameParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRecoverUsername(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRecoverUsername(response_);
                } catch (e) {
                    return <Observable<RecoverUsernameResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecoverUsernameResponse>><any>Observable.throw(response_);
        });
    }

    protected processRecoverUsername(response: Response): Observable<RecoverUsernameResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: RecoverUsernameResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverUsernameResponse.fromJS(resultData200) : new RecoverUsernameResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse | null> {
        let url_ = this.baseUrl + "/setPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setPasswordParams);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSetPassword(response_);
                } catch (e) {
                    return <Observable<SetPasswordResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<SetPasswordResponse>><any>Observable.throw(response_);
        });
    }

    protected processSetPassword(response: Response): Observable<SetPasswordResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: SetPasswordResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetPasswordResponse.fromJS(resultData200) : new SetPasswordResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<GetProfilesResponse | null> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetProfiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfiles(response_);
                } catch (e) {
                    return <Observable<GetProfilesResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilesResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetProfiles(response: Response): Observable<GetProfilesResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: GetProfilesResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilesResponse.fromJS(resultData200) : new GetProfilesResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<GetProfileResponse | null> {
        let url_ = this.baseUrl + "/profiles/myprofile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetMyProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMyProfile(response_);
                } catch (e) {
                    return <Observable<GetProfileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetMyProfile(response: Response): Observable<GetProfileResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: GetProfileResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResponse.fromJS(resultData200) : new GetProfileResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<GetProfileResponse | null> {
        let url_ = this.baseUrl + "/profiles/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProfile(response_);
                } catch (e) {
                    return <Observable<GetProfileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetProfile(response: Response): Observable<GetProfileResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: GetProfileResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfileResponse.fromJS(resultData200) : new GetProfileResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Retrieves all punches of current user
     * @return An array of products
     */
    getPunches(): Observable<PunchDto[] | null> {
        let url_ = this.baseUrl + "/punches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetPunches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPunches(response_);
                } catch (e) {
                    return <Observable<PunchDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetPunches(response: Response): Observable<PunchDto[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: PunchDto[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PunchDto.fromJS(item));
            }
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Retrieves all punches of current user of today
     * @return An day punches object
     */
    getToday(): Observable<DayResponse | null> {
        let url_ = this.baseUrl + "/punches/today";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetToday(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetToday(response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetToday(response: Response): Observable<DayResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: DayResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Retrieves all punches of current user current week
     * @return A week punches object
     */
    getThisWeek(): Observable<WeekResponse | null> {
        let url_ = this.baseUrl + "/punches/thisweek";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetThisWeek(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetThisWeek(response_);
                } catch (e) {
                    return <Observable<WeekResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<WeekResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetThisWeek(response: Response): Observable<WeekResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: WeekResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeekResponse.fromJS(resultData200) : new WeekResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Retrieves all punches of current user of current month
     * @return A month punches object
     */
    getThisMonth(): Observable<MonthResponse | null> {
        let url_ = this.baseUrl + "/punches/thismonth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetThisMonth(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetThisMonth(response_);
                } catch (e) {
                    return <Observable<MonthResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<MonthResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetThisMonth(response: Response): Observable<MonthResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: MonthResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MonthResponse.fromJS(resultData200) : new MonthResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Retrieves all punches of current user of current year
     * @return A year punches object
     */
    getThisYear(): Observable<YearResponse | null> {
        let url_ = this.baseUrl + "/punches/thisyear";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGetThisYear(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetThisYear(response_);
                } catch (e) {
                    return <Observable<YearResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<YearResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetThisYear(response: Response): Observable<YearResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: YearResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? YearResponse.fromJS(resultData200) : new YearResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchIn(): Observable<DayResponse | null> {
        let url_ = this.baseUrl + "/punches/punch/In";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchIn(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchIn(response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchIn(response: Response): Observable<DayResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: DayResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchOut(): Observable<DayResponse | null> {
        let url_ = this.baseUrl + "/punches/punch/Out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchOut(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchOut(response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DayResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchOut(response: Response): Observable<DayResponse | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: DayResponse | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return Observable.of(result200);
        } else {
            const _responseText = response.text();
            let result: PunchResponse | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return throwException("A server error occurred.", status, _responseText, result);
        }
    }

    /**
     * Modifiziert einen Zeitstempel
     * @return Unexpected error
     */
    punchModify(modifyPunchDto: ModifyPunchDto | undefined): Observable<PunchResponse | null> {
        let url_ = this.baseUrl + "/punchModify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyPunchDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchModify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchModify(response_);
                } catch (e) {
                    return <Observable<PunchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchModify(response: Response): Observable<PunchResponse | null> {
        const status = response.status; 

        {
            const _responseText = response.text();
            let result: PunchResponse | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return Observable.of(result);
        }
    }

    /**
     * Löscht einen Zeitstempel
     * @return Unexpected error
     */
    punchDelete(deletePunchDto: DeletePunchDto | undefined): Observable<OpResult | null> {
        let url_ = this.baseUrl + "/punchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deletePunchDto);
        
        let options_ = {
            body: content_,
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchDelete(response_);
                } catch (e) {
                    return <Observable<OpResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<OpResult>><any>Observable.throw(response_);
        });
    }

    protected processPunchDelete(response: Response): Observable<OpResult | null> {
        const status = response.status; 

        {
            const _responseText = response.text();
            let result: OpResult | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? OpResult.fromJS(resultData) : new OpResult();
            return Observable.of(result);
        }
    }

    /**
     * Modifiziert einen Zeitstempel
     * @return Unexpected error
     */
    punchModifyAdmin(modifyPunchAdminDto: ModifyPunchAdminDto | undefined): Observable<PunchResponse | null> {
        let url_ = this.baseUrl + "/punchModifyAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyPunchAdminDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchModifyAdmin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchModifyAdmin(response_);
                } catch (e) {
                    return <Observable<PunchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchModifyAdmin(response: Response): Observable<PunchResponse | null> {
        const status = response.status; 

        {
            const _responseText = response.text();
            let result: PunchResponse | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return Observable.of(result);
        }
    }

    /**
     * Setzt den Status der Monatsabrechung
     * @return Unexpected error
     */
    punchSetStatusAdmin(setStatusAdminDto: SetStatusAdminDto | undefined): Observable<PunchResponse | null> {
        let url_ = this.baseUrl + "/punchSetStatusAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setStatusAdminDto);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPunchSetStatusAdmin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPunchSetStatusAdmin(response_);
                } catch (e) {
                    return <Observable<PunchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PunchResponse>><any>Observable.throw(response_);
        });
    }

    protected processPunchSetStatusAdmin(response: Response): Observable<PunchResponse | null> {
        const status = response.status; 

        {
            const _responseText = response.text();
            let result: PunchResponse | null = null;
            let resultData = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result = resultData ? PunchResponse.fromJS(resultData) : new PunchResponse();
            return Observable.of(result);
        }
    }
}

export class AuthResponse implements IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.validFor = data["validFor"];
            this.id = data["id"];
            this.token = data["token"];
            this.refreshtoken = data["refreshtoken"];
        }
    }

    static fromJS(data: any): AuthResponse {
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["validFor"] = this.validFor;
        data["id"] = this.id;
        data["token"] = this.token;
        data["refreshtoken"] = this.refreshtoken;
        return data; 
    }
}

export interface IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;
}

export class CredentialDto implements ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ICredentialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.client_type = data["client_type"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CredentialDto {
        let result = new CredentialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_type"] = this.client_type;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.refresh_token = data["refresh_token"];
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refresh_token"] = this.refresh_token;
        return data; 
    }
}

export interface IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstname = data["firstname"];
            this.name = data["name"];
            this.email = data["email"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["name"] = this.name;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RegisterResponse implements IRegisterResponse {
    status?: OpResult | undefined;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterResponse {
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterResponse {
    status?: OpResult | undefined;
}

export class ConfirmResponse implements IConfirmResponse {
    status?: OpResult | undefined;

    constructor(data?: IConfirmResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmResponse {
        let result = new ConfirmResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConfirmResponse {
    status?: OpResult | undefined;
}

export class RecoverPasswordParams implements IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;

    constructor(data?: IRecoverPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): RecoverPasswordParams {
        let result = new RecoverPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        return data; 
    }
}

export interface IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
}

export class RecoverUsernameParams implements IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;

    constructor(data?: IRecoverUsernameParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): RecoverUsernameParams {
        let result = new RecoverUsernameParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
}

export class RecoverPasswordResponse implements IRecoverPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverPasswordResponse {
        let result = new RecoverPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverPasswordResponse {
    status?: OpResult | undefined;
}

export class RecoverUsernameResponse implements IRecoverUsernameResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverUsernameResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverUsernameResponse {
        let result = new RecoverUsernameResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverUsernameResponse {
    status?: OpResult | undefined;
}

export class SetPasswordParams implements ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ISetPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): SetPasswordParams {
        let result = new SetPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class SetPasswordResponse implements ISetPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: ISetPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetPasswordResponse {
        let result = new SetPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetPasswordResponse {
    status?: OpResult | undefined;
}

export class GetProfilesResponse implements IGetProfilesResponse {
    status?: OpResult | undefined;

    constructor(data?: IGetProfilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProfilesResponse {
        let result = new GetProfilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProfilesResponse {
    status?: OpResult | undefined;
}

export class GetProfileResponse implements IGetProfileResponse {
    status?: OpResult | undefined;

    constructor(data?: IGetProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProfileResponse {
        let result = new GetProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProfileResponse {
    status?: OpResult | undefined;
}

export class PunchResponse implements IPunchResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;

    constructor(data?: IPunchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? DayPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PunchResponse {
        let result = new PunchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPunchResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;
}

export class DayResponse implements IDayResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;

    constructor(data?: IDayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? DayPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DayResponse {
        let result = new DayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDayResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;
}

export class WeekResponse implements IWeekResponse {
    status?: OpResult | undefined;
    punches?: WeekPunchesDto | undefined;

    constructor(data?: IWeekResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? WeekPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WeekResponse {
        let result = new WeekResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWeekResponse {
    status?: OpResult | undefined;
    punches?: WeekPunchesDto | undefined;
}

export class MonthResponse implements IMonthResponse {
    status?: OpResult | undefined;
    punches?: MonthPunchesDto | undefined;

    constructor(data?: IMonthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? MonthPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MonthResponse {
        let result = new MonthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMonthResponse {
    status?: OpResult | undefined;
    punches?: MonthPunchesDto | undefined;
}

export class YearResponse implements IYearResponse {
    status?: OpResult | undefined;
    punches?: YearPunchesDto | undefined;

    constructor(data?: IYearResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? YearPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): YearResponse {
        let result = new YearResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IYearResponse {
    status?: OpResult | undefined;
    punches?: YearPunchesDto | undefined;
}

export class ModifyPunchDto implements IModifyPunchDto {
    punchid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;

    constructor(data?: IModifyPunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
            this.timedec = data["timedec"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): ModifyPunchDto {
        let result = new ModifyPunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IModifyPunchDto {
    punchid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;
}

export class DeletePunchDto implements IDeletePunchDto {
    punchid?: string | undefined;

    constructor(data?: IDeletePunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
        }
    }

    static fromJS(data: any): DeletePunchDto {
        let result = new DeletePunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        return data; 
    }
}

export interface IDeletePunchDto {
    punchid?: string | undefined;
}

export class ModifyPunchAdminDto implements IModifyPunchAdminDto {
    punchid?: string | undefined;
    userid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;

    constructor(data?: IModifyPunchAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
            this.userid = data["userid"];
            this.timedec = data["timedec"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): ModifyPunchAdminDto {
        let result = new ModifyPunchAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        data["userid"] = this.userid;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IModifyPunchAdminDto {
    punchid?: string | undefined;
    userid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;
}

export class SetStatusAdminDto implements ISetStatusAdminDto {
    userid?: string | undefined;
    status?: string | undefined;

    constructor(data?: ISetStatusAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userid = data["userid"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): SetStatusAdminDto {
        let result = new SetStatusAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userid"] = this.userid;
        data["status"] = this.status;
        return data; 
    }
}

export interface ISetStatusAdminDto {
    userid?: string | undefined;
    status?: string | undefined;
}

export class YearPunchesDto implements IYearPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: MonthPunchesDto[] | undefined;

    constructor(data?: IYearPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(MonthPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YearPunchesDto {
        let result = new YearPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IYearPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: MonthPunchesDto[] | undefined;
}

export class MonthPunchesDto implements IMonthPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: DayPunchesDto[] | undefined;

    constructor(data?: IMonthPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.month = data["month"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(DayPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MonthPunchesDto {
        let result = new MonthPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMonthPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: DayPunchesDto[] | undefined;
}

export class WeekPunchesDto implements IWeekPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The week expressed as 1 to 53 */
    week?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    dayPunches?: DayPunchesDto[] | undefined;

    constructor(data?: IWeekPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.week = data["week"];
            this.year = data["year"];
            if (data["dayPunches"] && data["dayPunches"].constructor === Array) {
                this.dayPunches = [];
                for (let item of data["dayPunches"])
                    this.dayPunches.push(DayPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeekPunchesDto {
        let result = new WeekPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["week"] = this.week;
        data["year"] = this.year;
        if (this.dayPunches && this.dayPunches.constructor === Array) {
            data["dayPunches"] = [];
            for (let item of this.dayPunches)
                data["dayPunches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeekPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The week expressed as 1 to 53 */
    week?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    dayPunches?: DayPunchesDto[] | undefined;
}

export class DayPunchesDto implements IDayPunchesDto {
    /** Boid of user */
    userboid?: string | undefined;
    /** The day expressed as value betwenn 1 and 31 */
    day?: number | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: PunchRowDto[] | undefined;
    daytotal?: number | undefined;

    constructor(data?: IDayPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userboid = data["userboid"];
            this.day = data["day"];
            this.month = data["month"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(PunchRowDto.fromJS(item));
            }
            this.daytotal = data["daytotal"];
        }
    }

    static fromJS(data: any): DayPunchesDto {
        let result = new DayPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userboid"] = this.userboid;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        data["daytotal"] = this.daytotal;
        return data; 
    }
}

export interface IDayPunchesDto {
    /** Boid of user */
    userboid?: string | undefined;
    /** The day expressed as value betwenn 1 and 31 */
    day?: number | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: PunchRowDto[] | undefined;
    daytotal?: number | undefined;
}

export class PunchRowDto implements IPunchRowDto {
    enter?: PunchDto | undefined;
    leave?: PunchDto | undefined;
    /** Time between enter and leav */
    rowTotal?: number | undefined;

    constructor(data?: IPunchRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.enter = data["enter"] ? PunchDto.fromJS(data["enter"]) : <any>undefined;
            this.leave = data["leave"] ? PunchDto.fromJS(data["leave"]) : <any>undefined;
            this.rowTotal = data["rowTotal"];
        }
    }

    static fromJS(data: any): PunchRowDto {
        let result = new PunchRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enter"] = this.enter ? this.enter.toJSON() : <any>undefined;
        data["leave"] = this.leave ? this.leave.toJSON() : <any>undefined;
        data["rowTotal"] = this.rowTotal;
        return data; 
    }
}

export interface IPunchRowDto {
    enter?: PunchDto | undefined;
    leave?: PunchDto | undefined;
    /** Time between enter and leav */
    rowTotal?: number | undefined;
}

export class PunchDto implements IPunchDto {
    time?: Date | undefined;
    timedec?: number | undefined;
    /** True means enter work, False means leave work. */
    direction?: boolean | undefined;
    /** The timestamp of the creation of this value. */
    created?: Date | undefined;
    /** The timestamp of the last update of this value. */
    updated?: Date | undefined;
    punchid?: string | undefined;

    constructor(data?: IPunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.timedec = data["timedec"];
            this.direction = data["direction"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.updated = data["updated"] ? new Date(data["updated"].toString()) : <any>undefined;
            this.punchid = data["punchid"];
        }
    }

    static fromJS(data: any): PunchDto {
        let result = new PunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["punchid"] = this.punchid;
        return data; 
    }
}

export interface IPunchDto {
    time?: Date | undefined;
    timedec?: number | undefined;
    /** True means enter work, False means leave work. */
    direction?: boolean | undefined;
    /** The timestamp of the creation of this value. */
    created?: Date | undefined;
    /** The timestamp of the last update of this value. */
    updated?: Date | undefined;
    punchid?: string | undefined;
}

export class OpResult implements IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;

    constructor(data?: IOpResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): OpResult {
        let result = new OpResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["result"] = this.result;
        return data; 
    }
}

export interface IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}