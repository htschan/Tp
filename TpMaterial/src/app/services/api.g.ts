/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.13.0 (NJsonSchema v9.10.50.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ITpClient {
    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Credentials mit E-Mail und Passwort.
     * @return Returns nothing
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse>;
    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse>;
    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse>;
    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse>;
    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse>;
    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse>;
    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse>;
    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<ProfileResponseDto>;
    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<ProfileResponseDto>;
    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<ProfileResponseDto>;
    /**
     * Send email message to system administrator
     * @mailMessage The mail content
     * @return Mail sent
     */
    sendMail(mailMessage: MailDto): Observable<void>;
    /**
     * Send slack message to system administrator
     * @slackMessage The message content
     * @return Slack sent
     */
    sendSlack(slackMessage: MailDto): Observable<void>;
    /**
     * Get the list of users [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns users
     */
    adminGetUsers(): Observable<UsersDto>;
    /**
     * Get the list of sessions [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns sessions
     */
    adminGetSessions(): Observable<SessionsDto>;
    /**
     * Retrieves all punches of current user
     * @return An array of products
     */
    getPunches(): Observable<PunchDto[]>;
    /**
     * Retrieves all punches of current user of selected day
     * @day (optional) The day selector [1 .. 31]
     * @month (optional) The month number selector [1 .. 12]
     * @year (optional) The year number selector [2015 .. 2099]
     * @return An day punches object
     */
    getDay(day: number | null | undefined, month: number | null | undefined, year: number | null | undefined): Observable<DayResponse>;
    /**
     * Retrieves all punches of current user selected week
     * @week (optional) The week number selector
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A week punches object
     */
    getWeek(week: number | null | undefined, year: number | null | undefined): Observable<WeekResponse>;
    /**
     * Retrieves all punches of current user of selected month
     * @month (optional) The month number selector [1 .. 12]
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    getMonth(month: number | null | undefined, year: number | null | undefined): Observable<MonthResponse>;
    /**
     * Retrieves all punches of current user of selected year
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A year punches object
     */
    getYear(year: number | null | undefined): Observable<YearResponse>;
    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchIn(): Observable<DayResponse>;
    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchOut(): Observable<DayResponse>;
    /**
     * Modifiziert einen Zeitstempel
     * @modifyPunchDto (optional) 
     * @return Punch modified
     */
    punchModify(modifyPunchDto: ModifyPunchDto | null | undefined): Observable<void>;
    /**
     * Löscht einen Zeitstempel
     * @deletePunchDto (optional) 
     * @return Punch deleted
     */
    punchDelete(deletePunchDto: DeletePunchDto | null | undefined): Observable<void>;
    /**
     * Get the list of users [Authorize(Policy = "RequireApiPowerRole")]
     * @return Returns users
     */
    puGetUsers(): Observable<UsersDto>;
    /**
     * Retrieves all punches of current user of selected month
     * @userId The user id
     * @month (optional) The month number selector [1 .. 12]
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    puGetMonth(userId: string, month: number | null | undefined, year: number | null | undefined): Observable<MonthResponse>;
    /**
     * Modifiziert einen Zeitstempel [Authorize(Policy = "RequireApiPowerRole")]
     * @modifyPunchAdminDto (optional) 
     * @return Punch modified
     */
    puModifyPunch(modifyPunchAdminDto: ModifyPunchAdminDto | null | undefined): Observable<void>;
    /**
     * Setzt den Status der Monatsabrechung [Authorize(Policy = "RequireApiPowerRole")]
     * @setStatusAdminDto (optional) 
     * @return Month status set
     */
    puSetMonthStatus(setStatusAdminDto: StatusAdminDto | null | undefined): Observable<void>;
}

@Injectable()
export class TpClient implements ITpClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:3000/api/v1";
    }

    /**
     * Sendet eine Authentifizierungsanfrage an den Server [AllowAnonymous]
     * @credentials Credentials mit E-Mail und Passwort.
     * @return Returns nothing
     */
    authenticate(credentials: CredentialDto): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(credentials);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthResponse.fromJS(resultData200) : new AuthResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthResponse>(<any>null);
    }

    /**
     * Sendet eine RefreshToken Abfrage an den Server [AllowAnonymous]
     * @refreshtokenparameter Eine ASCII-Zeichenfolge mit mindestens einem Zeichen.
     * @return AuthResponse
     */
    refreshtoken(refreshtokenparameter: RefreshTokenDto): Observable<AuthResponse> {
        let url_ = this.baseUrl + "/refreshtoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshtokenparameter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshtoken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshtoken(<any>response_);
                } catch (e) {
                    return <Observable<AuthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshtoken(response: HttpResponseBase): Observable<AuthResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthResponse.fromJS(resultData200) : new AuthResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthResponse>(<any>null);
    }

    /**
     * Einen Benutzer registrieren [AllowAnonymous]
     * @registerDto Registrierungsinformationen
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Bestätigungslink.
     */
    registerUser(registerDto: RegisterDto): Observable<RegisterResponse> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<RegisterResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<RegisterResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterResponse.fromJS(resultData200) : new RegisterResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterResponse>(<any>null);
    }

    /**
     * Eine Benutzerregistrierung bestätigen [AllowAnonymous]
     * @id Userid
     * @cnf Confirmationtoken
     * @return Die Operation war erfolgreich.
     */
    confirmRegister(id: string, cnf: string): Observable<ConfirmResponse> {
        let url_ = this.baseUrl + "/confirm?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (cnf === undefined || cnf === null)
            throw new Error("The parameter 'cnf' must be defined and cannot be null.");
        else
            url_ += "cnf=" + encodeURIComponent("" + cnf) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmRegister(<any>response_);
                } catch (e) {
                    return <Observable<ConfirmResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConfirmResponse>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmRegister(response: HttpResponseBase): Observable<ConfirmResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConfirmResponse.fromJS(resultData200) : new ConfirmResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfirmResponse>(<any>null);
    }

    /**
     * Passwort wiederherstellen [AllowAnonymous]
     * @recoverPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit einem Passwortresetcode.
     */
    recoverPassword(recoverPasswordParams: RecoverPasswordParams): Observable<RecoverPasswordResponse> {
        let url_ = this.baseUrl + "/recoverPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverPasswordParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecoverPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecoverPassword(<any>response_);
                } catch (e) {
                    return <Observable<RecoverPasswordResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecoverPasswordResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRecoverPassword(response: HttpResponseBase): Observable<RecoverPasswordResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverPasswordResponse.fromJS(resultData200) : new RecoverPasswordResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecoverPasswordResponse>(<any>null);
    }

    /**
     * Abfrage des Usernamens [AllowAnonymous]
     * @recoverUsernameParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich. Der Benutzer erhält eine E-Mail mit seinem Benutzernamen.
     */
    recoverUsername(recoverUsernameParams: RecoverUsernameParams): Observable<RecoverUsernameResponse> {
        let url_ = this.baseUrl + "/recoverUsername";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recoverUsernameParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecoverUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecoverUsername(<any>response_);
                } catch (e) {
                    return <Observable<RecoverUsernameResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecoverUsernameResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRecoverUsername(response: HttpResponseBase): Observable<RecoverUsernameResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RecoverUsernameResponse.fromJS(resultData200) : new RecoverUsernameResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecoverUsernameResponse>(<any>null);
    }

    /**
     * Ein Benutzer setzt ein neues Passwort [AllowAnonymous]
     * @setPasswordParams Wiederherstellungsparameter
     * @return Die Operation war erfolgreich.
     */
    setPassword(setPasswordParams: SetPasswordParams): Observable<SetPasswordResponse> {
        let url_ = this.baseUrl + "/setPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setPasswordParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(<any>response_);
                } catch (e) {
                    return <Observable<SetPasswordResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetPasswordResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<SetPasswordResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SetPasswordResponse.fromJS(resultData200) : new SetPasswordResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetPasswordResponse>(<any>null);
    }

    /**
     * Abfrage aller Profile
     * @return Die Operation war erfolgreich.
     */
    getProfiles(): Observable<ProfileResponseDto> {
        let url_ = this.baseUrl + "/profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfiles(<any>response_);
                } catch (e) {
                    return <Observable<ProfileResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfiles(response: HttpResponseBase): Observable<ProfileResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileResponseDto.fromJS(resultData200) : new ProfileResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileResponseDto>(<any>null);
    }

    /**
     * Abfrage des eigenen Profils
     * @return Die Operation war erfolgreich.
     */
    getMyProfile(): Observable<ProfileResponseDto> {
        let url_ = this.baseUrl + "/profiles/myprofile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMyProfile(response: HttpResponseBase): Observable<ProfileResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileResponseDto.fromJS(resultData200) : new ProfileResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileResponseDto>(<any>null);
    }

    /**
     * Abfrage eines Benutzerprofiles
     * @userid User Id
     * @return Die Operation war erfolgreich.
     */
    getProfile(userid: string): Observable<ProfileResponseDto> {
        let url_ = this.baseUrl + "/profiles/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<ProfileResponseDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileResponseDto.fromJS(resultData200) : new ProfileResponseDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileResponseDto>(<any>null);
    }

    /**
     * Send email message to system administrator
     * @mailMessage The mail content
     * @return Mail sent
     */
    sendMail(mailMessage: MailDto): Observable<void> {
        let url_ = this.baseUrl + "/sendMail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mailMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Send slack message to system administrator
     * @slackMessage The message content
     * @return Slack sent
     */
    sendSlack(slackMessage: MailDto): Observable<void> {
        let url_ = this.baseUrl + "/sendSlack";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(slackMessage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSlack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSlack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendSlack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get the list of users [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns users
     */
    adminGetUsers(): Observable<UsersDto> {
        let url_ = this.baseUrl + "/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UsersDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersDto>><any>_observableThrow(response_);
        }));
    }

    protected processAdminGetUsers(response: HttpResponseBase): Observable<UsersDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersDto.fromJS(resultData200) : new UsersDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersDto>(<any>null);
    }

    /**
     * Get the list of sessions [Authorize(Policy = "RequireApiAdminRole")]
     * @return Returns sessions
     */
    adminGetSessions(): Observable<SessionsDto> {
        let url_ = this.baseUrl + "/admin/sessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminGetSessions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminGetSessions(<any>response_);
                } catch (e) {
                    return <Observable<SessionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SessionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processAdminGetSessions(response: HttpResponseBase): Observable<SessionsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SessionsDto.fromJS(resultData200) : new SessionsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SessionsDto>(<any>null);
    }

    /**
     * Retrieves all punches of current user
     * @return An array of products
     */
    getPunches(): Observable<PunchDto[]> {
        let url_ = this.baseUrl + "/punches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPunches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPunches(<any>response_);
                } catch (e) {
                    return <Observable<PunchDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PunchDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPunches(response: HttpResponseBase): Observable<PunchDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PunchDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PunchDto[]>(<any>null);
    }

    /**
     * Retrieves all punches of current user of selected day
     * @day (optional) The day selector [1 .. 31]
     * @month (optional) The month number selector [1 .. 12]
     * @year (optional) The year number selector [2015 .. 2099]
     * @return An day punches object
     */
    getDay(day: number | null | undefined, month: number | null | undefined, year: number | null | undefined): Observable<DayResponse> {
        let url_ = this.baseUrl + "/punches/day?";
        if (day !== undefined)
            url_ += "day=" + encodeURIComponent("" + day) + "&"; 
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDay(<any>response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DayResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDay(response: HttpResponseBase): Observable<DayResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DayResponse>(<any>null);
    }

    /**
     * Retrieves all punches of current user selected week
     * @week (optional) The week number selector
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A week punches object
     */
    getWeek(week: number | null | undefined, year: number | null | undefined): Observable<WeekResponse> {
        let url_ = this.baseUrl + "/punches/week?";
        if (week !== undefined)
            url_ += "week=" + encodeURIComponent("" + week) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeek(<any>response_);
                } catch (e) {
                    return <Observable<WeekResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeekResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeek(response: HttpResponseBase): Observable<WeekResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeekResponse.fromJS(resultData200) : new WeekResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeekResponse>(<any>null);
    }

    /**
     * Retrieves all punches of current user of selected month
     * @month (optional) The month number selector [1 .. 12]
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    getMonth(month: number | null | undefined, year: number | null | undefined): Observable<MonthResponse> {
        let url_ = this.baseUrl + "/punches/month?";
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonth(<any>response_);
                } catch (e) {
                    return <Observable<MonthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<MonthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetMonth(response: HttpResponseBase): Observable<MonthResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MonthResponse.fromJS(resultData200) : new MonthResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MonthResponse>(<any>null);
    }

    /**
     * Retrieves all punches of current user of selected year
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A year punches object
     */
    getYear(year: number | null | undefined): Observable<YearResponse> {
        let url_ = this.baseUrl + "/punches/year?";
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYear(<any>response_);
                } catch (e) {
                    return <Observable<YearResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<YearResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetYear(response: HttpResponseBase): Observable<YearResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? YearResponse.fromJS(resultData200) : new YearResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YearResponse>(<any>null);
    }

    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchIn(): Observable<DayResponse> {
        let url_ = this.baseUrl + "/punches/punch/In";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPunchIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPunchIn(<any>response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DayResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPunchIn(response: HttpResponseBase): Observable<DayResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DayResponse>(<any>null);
    }

    /**
     * Erzeugt einen Zeitstempel
     * @return Liefert die Tagesstempel zurück
     */
    punchOut(): Observable<DayResponse> {
        let url_ = this.baseUrl + "/punches/punch/Out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPunchOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPunchOut(<any>response_);
                } catch (e) {
                    return <Observable<DayResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DayResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPunchOut(response: HttpResponseBase): Observable<DayResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DayResponse.fromJS(resultData200) : new DayResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DayResponse>(<any>null);
    }

    /**
     * Modifiziert einen Zeitstempel
     * @modifyPunchDto (optional) 
     * @return Punch modified
     */
    punchModify(modifyPunchDto: ModifyPunchDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/punchModify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyPunchDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPunchModify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPunchModify(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPunchModify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Löscht einen Zeitstempel
     * @deletePunchDto (optional) 
     * @return Punch deleted
     */
    punchDelete(deletePunchDto: DeletePunchDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/punchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deletePunchDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPunchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPunchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPunchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get the list of users [Authorize(Policy = "RequireApiPowerRole")]
     * @return Returns users
     */
    puGetUsers(): Observable<UsersDto> {
        let url_ = this.baseUrl + "/poweruser/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPuGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPuGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UsersDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersDto>><any>_observableThrow(response_);
        }));
    }

    protected processPuGetUsers(response: HttpResponseBase): Observable<UsersDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersDto.fromJS(resultData200) : new UsersDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersDto>(<any>null);
    }

    /**
     * Retrieves all punches of current user of selected month
     * @userId The user id
     * @month (optional) The month number selector [1 .. 12]
     * @year (optional) The year number selector [2015 .. 2099]
     * @return A month punches object
     */
    puGetMonth(userId: string, month: number | null | undefined, year: number | null | undefined): Observable<MonthResponse> {
        let url_ = this.baseUrl + "/poweruser/punches/month?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&"; 
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPuGetMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPuGetMonth(<any>response_);
                } catch (e) {
                    return <Observable<MonthResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<MonthResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPuGetMonth(response: HttpResponseBase): Observable<MonthResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MonthResponse.fromJS(resultData200) : new MonthResponse();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MonthResponse>(<any>null);
    }

    /**
     * Modifiziert einen Zeitstempel [Authorize(Policy = "RequireApiPowerRole")]
     * @modifyPunchAdminDto (optional) 
     * @return Punch modified
     */
    puModifyPunch(modifyPunchAdminDto: ModifyPunchAdminDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/poweruser/punchModify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyPunchAdminDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPuModifyPunch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPuModifyPunch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPuModifyPunch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Setzt den Status der Monatsabrechung [Authorize(Policy = "RequireApiPowerRole")]
     * @setStatusAdminDto (optional) 
     * @return Month status set
     */
    puSetMonthStatus(setStatusAdminDto: StatusAdminDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/poweruser/setMonthStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setStatusAdminDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPuSetMonthStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPuSetMonthStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPuSetMonthStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class AuthResponse implements IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.validFor = data["validFor"];
            this.id = data["id"];
            this.token = data["token"];
            this.refreshtoken = data["refreshtoken"];
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["validFor"] = this.validFor;
        data["id"] = this.id;
        data["token"] = this.token;
        data["refreshtoken"] = this.refreshtoken;
        return data; 
    }
}

export interface IAuthResponse {
    status?: OpResult | undefined;
    /** The token will be valid for validFor seconds */
    validFor?: number | undefined;
    /** The user id */
    id?: string | undefined;
    /** Ein Authentifizierungstoken mit dem alle folgenden Aufrufe authentifiziert werden. */
    token?: string | undefined;
    /** Ein RefreshToken mit dem der token erneuert werden kann. */
    refreshtoken?: string | undefined;
}

export class CredentialDto implements ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ICredentialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.client_type = data["client_type"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CredentialDto {
        data = typeof data === 'object' ? data : {};
        let result = new CredentialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client_type"] = this.client_type;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICredentialDto {
    /** Der Client-Typ 'web', 'ionic' */
    client_type?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.refresh_token = data["refresh_token"];
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refresh_token"] = this.refresh_token;
        return data; 
    }
}

export interface IRefreshTokenDto {
    /** Der Refresh Token */
    refresh_token?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstname = data["firstname"];
            this.name = data["name"];
            this.email = data["email"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstname"] = this.firstname;
        data["name"] = this.name;
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegisterDto {
    /** Der Vorname, 1 .. 80 Zeichen */
    firstname?: string | undefined;
    /** Der Name, 1 .. 80 Zeichen */
    name?: string | undefined;
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class RegisterResponse implements IRegisterResponse {
    status?: OpResult | undefined;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegisterResponse {
    status?: OpResult | undefined;
}

export class ConfirmResponse implements IConfirmResponse {
    status?: OpResult | undefined;

    constructor(data?: IConfirmResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConfirmResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IConfirmResponse {
    status?: OpResult | undefined;
}

export class RecoverPasswordParams implements IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;

    constructor(data?: IRecoverPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): RecoverPasswordParams {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        return data; 
    }
}

export interface IRecoverPasswordParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
}

export class RecoverUsernameParams implements IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;

    constructor(data?: IRecoverUsernameParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
        }
    }

    static fromJS(data: any): RecoverUsernameParams {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverUsernameParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IRecoverUsernameParams {
    /** Die E-Mail Adresse 1 .. 160 Zeichen. Wird benötigt für die Bestätigung der Kontoerstellung. */
    email?: string | undefined;
}

export class RecoverPasswordResponse implements IRecoverPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverPasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverPasswordResponse {
    status?: OpResult | undefined;
}

export class RecoverUsernameResponse implements IRecoverUsernameResponse {
    status?: OpResult | undefined;

    constructor(data?: IRecoverUsernameResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecoverUsernameResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverUsernameResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRecoverUsernameResponse {
    status?: OpResult | undefined;
}

export class SetPasswordParams implements ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;

    constructor(data?: ISetPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.username = data["username"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): SetPasswordParams {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISetPasswordParams {
    /** Der Passwortresetcode. */
    code?: string | undefined;
    /** Der Benutzername 1 .. 80 Zeichen. Wird für das Anmeldung benötigt. */
    username?: string | undefined;
    /** Das Passwort 1 .. 80 Zeichen. Wird für die Anmeldung benötigt. */
    password?: string | undefined;
}

export class SetPasswordResponse implements ISetPasswordResponse {
    status?: OpResult | undefined;

    constructor(data?: ISetPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SetPasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetPasswordResponse {
    status?: OpResult | undefined;
}

export class ProfileResponseDto implements IProfileResponseDto {
    /** The user profile id */
    id?: string | undefined;
    /** The profile picture url */
    pictureUrl?: string | undefined;
    user?: UserDto | undefined;
    status?: OpResult | undefined;

    constructor(data?: IProfileResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.pictureUrl = data["pictureUrl"];
            this.user = data["user"] ? UserDto.fromJS(data["user"]) : <any>undefined;
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfileResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pictureUrl"] = this.pictureUrl;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProfileResponseDto {
    /** The user profile id */
    id?: string | undefined;
    /** The profile picture url */
    pictureUrl?: string | undefined;
    user?: UserDto | undefined;
    status?: OpResult | undefined;
}

export class PunchResponse implements IPunchResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;

    constructor(data?: IPunchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? DayPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PunchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PunchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPunchResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;
}

export class DayResponse implements IDayResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;

    constructor(data?: IDayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? DayPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DayResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDayResponse {
    status?: OpResult | undefined;
    punches?: DayPunchesDto | undefined;
}

export class WeekResponse implements IWeekResponse {
    status?: OpResult | undefined;
    punches?: WeekPunchesDto | undefined;

    constructor(data?: IWeekResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? WeekPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WeekResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WeekResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWeekResponse {
    status?: OpResult | undefined;
    punches?: WeekPunchesDto | undefined;
}

export class MonthResponse implements IMonthResponse {
    status?: OpResult | undefined;
    punches?: MonthPunchesDto | undefined;

    constructor(data?: IMonthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? MonthPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MonthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MonthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMonthResponse {
    status?: OpResult | undefined;
    punches?: MonthPunchesDto | undefined;
}

export class YearResponse implements IYearResponse {
    status?: OpResult | undefined;
    punches?: YearPunchesDto | undefined;

    constructor(data?: IYearResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"] ? OpResult.fromJS(data["status"]) : <any>undefined;
            this.punches = data["punches"] ? YearPunchesDto.fromJS(data["punches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): YearResponse {
        data = typeof data === 'object' ? data : {};
        let result = new YearResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["punches"] = this.punches ? this.punches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IYearResponse {
    status?: OpResult | undefined;
    punches?: YearPunchesDto | undefined;
}

export class ModifyPunchDto implements IModifyPunchDto {
    punchid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;

    constructor(data?: IModifyPunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
            this.timedec = data["timedec"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): ModifyPunchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModifyPunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IModifyPunchDto {
    punchid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;
}

export class DeletePunchDto implements IDeletePunchDto {
    punchid?: string | undefined;

    constructor(data?: IDeletePunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
        }
    }

    static fromJS(data: any): DeletePunchDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeletePunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        return data; 
    }
}

export interface IDeletePunchDto {
    punchid?: string | undefined;
}

export class ModifyPunchAdminDto implements IModifyPunchAdminDto {
    punchid?: string | undefined;
    userid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;

    constructor(data?: IModifyPunchAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.punchid = data["punchid"];
            this.userid = data["userid"];
            this.timedec = data["timedec"];
            this.direction = data["direction"];
        }
    }

    static fromJS(data: any): ModifyPunchAdminDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModifyPunchAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["punchid"] = this.punchid;
        data["userid"] = this.userid;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IModifyPunchAdminDto {
    punchid?: string | undefined;
    userid?: string | undefined;
    timedec?: number | undefined;
    direction?: boolean | undefined;
}

export class StatusAdminDto implements IStatusAdminDto {
    userid?: string | undefined;
    /** The month status */
    status?: StatusAdminDtoStatus | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;

    constructor(data?: IStatusAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.status = StatusAdminDtoStatus.Open;
        }
    }

    init(data?: any) {
        if (data) {
            this.userid = data["userid"];
            this.status = data["status"] !== undefined ? data["status"] : StatusAdminDtoStatus.Open;
            this.month = data["month"];
            this.year = data["year"];
        }
    }

    static fromJS(data: any): StatusAdminDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusAdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userid"] = this.userid;
        data["status"] = this.status;
        data["month"] = this.month;
        data["year"] = this.year;
        return data; 
    }
}

export interface IStatusAdminDto {
    userid?: string | undefined;
    /** The month status */
    status?: StatusAdminDtoStatus | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
}

export class UsersDto implements IUsersDto {
    users?: UserDto[] | undefined;

    constructor(data?: IUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsersDto {
    users?: UserDto[] | undefined;
}

export class UserDto implements IUserDto {
    /** The user id */
    id?: string | undefined;
    /** The first name of user */
    firstName?: string | undefined;
    /** The last name of user */
    lastName?: string | undefined;
    /** The email of the user */
    email?: string | undefined;
    /** The confirmed status of the user registration */
    emailConfirmed?: boolean | undefined;
    /** The number of failed access attempts */
    accessFailedCount?: number | undefined;
    roleNames?: RoleDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.emailConfirmed = data["emailConfirmed"];
            this.accessFailedCount = data["accessFailedCount"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["accessFailedCount"] = this.accessFailedCount;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserDto {
    /** The user id */
    id?: string | undefined;
    /** The first name of user */
    firstName?: string | undefined;
    /** The last name of user */
    lastName?: string | undefined;
    /** The email of the user */
    email?: string | undefined;
    /** The confirmed status of the user registration */
    emailConfirmed?: boolean | undefined;
    /** The number of failed access attempts */
    accessFailedCount?: number | undefined;
    roleNames?: RoleDto[] | undefined;
}

export class RoleDto implements IRoleDto {
    /** Name of role */
    name?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IRoleDto {
    /** Name of role */
    name?: string | undefined;
}

export class SessionsDto implements ISessionsDto {
    sessions?: SessionDto[] | undefined;

    constructor(data?: ISessionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["sessions"] && data["sessions"].constructor === Array) {
                this.sessions = [];
                for (let item of data["sessions"])
                    this.sessions.push(SessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SessionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.sessions && this.sessions.constructor === Array) {
            data["sessions"] = [];
            for (let item of this.sessions)
                data["sessions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISessionsDto {
    sessions?: SessionDto[] | undefined;
}

export class SessionDto implements ISessionDto {
    /** Then sessions id */
    id?: string | undefined;
    /** The userid associated with the session */
    userid?: string | undefined;
    /** the email of the user */
    email?: string | undefined;
    /** The timestamp of the creation */
    created?: string | undefined;
    /** True if the session is stopped */
    isStop?: boolean | undefined;

    constructor(data?: ISessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userid = data["userid"];
            this.email = data["email"];
            this.created = data["created"];
            this.isStop = data["isStop"];
        }
    }

    static fromJS(data: any): SessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userid"] = this.userid;
        data["email"] = this.email;
        data["created"] = this.created;
        data["isStop"] = this.isStop;
        return data; 
    }
}

export interface ISessionDto {
    /** Then sessions id */
    id?: string | undefined;
    /** The userid associated with the session */
    userid?: string | undefined;
    /** the email of the user */
    email?: string | undefined;
    /** The timestamp of the creation */
    created?: string | undefined;
    /** True if the session is stopped */
    isStop?: boolean | undefined;
}

export class MailDto implements IMailDto {
    /** The mail subject */
    subject?: string | undefined;
    /** The body text */
    body?: string | undefined;

    constructor(data?: IMailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subject = data["subject"];
            this.body = data["body"];
        }
    }

    static fromJS(data: any): MailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data; 
    }
}

export interface IMailDto {
    /** The mail subject */
    subject?: string | undefined;
    /** The body text */
    body?: string | undefined;
}

export class YearPunchesDto implements IYearPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: MonthPunchesDto[] | undefined;

    constructor(data?: IYearPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(MonthPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YearPunchesDto {
        data = typeof data === 'object' ? data : {};
        let result = new YearPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IYearPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: MonthPunchesDto[] | undefined;
}

export class MonthPunchesDto implements IMonthPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    state?: StatusAdminDto | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: DayPunchesDto[] | undefined;

    constructor(data?: IMonthPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.state = data["state"] ? StatusAdminDto.fromJS(data["state"]) : <any>undefined;
            this.month = data["month"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(DayPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MonthPunchesDto {
        data = typeof data === 'object' ? data : {};
        let result = new MonthPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMonthPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    state?: StatusAdminDto | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: DayPunchesDto[] | undefined;
}

export class WeekPunchesDto implements IWeekPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The week expressed as 1 to 53 */
    week?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    dayPunches?: DayPunchesDto[] | undefined;

    constructor(data?: IWeekPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"];
            this.week = data["week"];
            this.year = data["year"];
            if (data["dayPunches"] && data["dayPunches"].constructor === Array) {
                this.dayPunches = [];
                for (let item of data["dayPunches"])
                    this.dayPunches.push(DayPunchesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WeekPunchesDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeekPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["week"] = this.week;
        data["year"] = this.year;
        if (this.dayPunches && this.dayPunches.constructor === Array) {
            data["dayPunches"] = [];
            for (let item of this.dayPunches)
                data["dayPunches"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWeekPunchesDto {
    /** Boid of user */
    user?: string | undefined;
    /** The week expressed as 1 to 53 */
    week?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    dayPunches?: DayPunchesDto[] | undefined;
}

export class DayPunchesDto implements IDayPunchesDto {
    /** Boid of user */
    userboid?: string | undefined;
    /** The day expressed as value betwenn 1 and 31 */
    day?: number | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: PunchRowDto[] | undefined;
    daytotal?: number | undefined;

    constructor(data?: IDayPunchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userboid = data["userboid"];
            this.day = data["day"];
            this.month = data["month"];
            this.year = data["year"];
            if (data["punches"] && data["punches"].constructor === Array) {
                this.punches = [];
                for (let item of data["punches"])
                    this.punches.push(PunchRowDto.fromJS(item));
            }
            this.daytotal = data["daytotal"];
        }
    }

    static fromJS(data: any): DayPunchesDto {
        data = typeof data === 'object' ? data : {};
        let result = new DayPunchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userboid"] = this.userboid;
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        if (this.punches && this.punches.constructor === Array) {
            data["punches"] = [];
            for (let item of this.punches)
                data["punches"].push(item.toJSON());
        }
        data["daytotal"] = this.daytotal;
        return data; 
    }
}

export interface IDayPunchesDto {
    /** Boid of user */
    userboid?: string | undefined;
    /** The day expressed as value betwenn 1 and 31 */
    day?: number | undefined;
    /** The month expressed as value between 1 and 12 */
    month?: number | undefined;
    /** The year expressed as 1 to 9999 */
    year?: number | undefined;
    punches?: PunchRowDto[] | undefined;
    daytotal?: number | undefined;
}

export class PunchRowDto implements IPunchRowDto {
    enter?: PunchDto | undefined;
    leave?: PunchDto | undefined;
    /** Time between enter and leav */
    rowTotal?: number | undefined;

    constructor(data?: IPunchRowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.enter = data["enter"] ? PunchDto.fromJS(data["enter"]) : <any>undefined;
            this.leave = data["leave"] ? PunchDto.fromJS(data["leave"]) : <any>undefined;
            this.rowTotal = data["rowTotal"];
        }
    }

    static fromJS(data: any): PunchRowDto {
        data = typeof data === 'object' ? data : {};
        let result = new PunchRowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enter"] = this.enter ? this.enter.toJSON() : <any>undefined;
        data["leave"] = this.leave ? this.leave.toJSON() : <any>undefined;
        data["rowTotal"] = this.rowTotal;
        return data; 
    }
}

export interface IPunchRowDto {
    enter?: PunchDto | undefined;
    leave?: PunchDto | undefined;
    /** Time between enter and leav */
    rowTotal?: number | undefined;
}

export class PunchDto implements IPunchDto {
    time?: Date | undefined;
    timedec?: number | undefined;
    /** True means enter work, False means leave work. */
    direction?: boolean | undefined;
    /** The timestamp of the creation of this value. */
    created?: Date | undefined;
    /** The timestamp of the last update of this value. */
    updated?: Date | undefined;
    punchid?: string | undefined;

    constructor(data?: IPunchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
            this.timedec = data["timedec"];
            this.direction = data["direction"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.updated = data["updated"] ? new Date(data["updated"].toString()) : <any>undefined;
            this.punchid = data["punchid"];
        }
    }

    static fromJS(data: any): PunchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PunchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["timedec"] = this.timedec;
        data["direction"] = this.direction;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["punchid"] = this.punchid;
        return data; 
    }
}

export interface IPunchDto {
    time?: Date | undefined;
    timedec?: number | undefined;
    /** True means enter work, False means leave work. */
    direction?: boolean | undefined;
    /** The timestamp of the creation of this value. */
    created?: Date | undefined;
    /** The timestamp of the last update of this value. */
    updated?: Date | undefined;
    punchid?: string | undefined;
}

export class OpResult implements IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;

    constructor(data?: IOpResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): OpResult {
        data = typeof data === 'object' ? data : {};
        let result = new OpResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["result"] = this.result;
        return data; 
    }
}

export interface IOpResult {
    /** True wenn die Operation erfolgreich war */
    success?: boolean | undefined;
    /** Eine Text-Meldung */
    result?: string | undefined;
}

export enum StatusAdminDtoStatus {
    Open = "open", 
    OpenAdmin = "openAdmin", 
    Closed = "closed", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}